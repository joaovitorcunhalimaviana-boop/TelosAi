// PDF Export System with Professional Layout
// jsPDF, autoTable and html2canvas are dynamically imported to reduce bundle size
import type { RowInput } from 'jspdf-autotable';

// ============================================
// TYPE DEFINITIONS
// ============================================

export interface PDFReportOptions {
  title: string;
  subtitle?: string;
  author: string;
  date: Date;
  includeTableOfContents: boolean;
  includeCoverPage: boolean;
  includeWatermark: boolean;
  orientation: 'portrait' | 'landscape';
  language: 'pt' | 'en';
}

export interface PDFSection {
  title: string;
  content: PDFContent[];
  pageBreakBefore?: boolean;
}

export type PDFContent =
  | { type: 'text'; text: string; style?: 'normal' | 'bold' | 'italic' | 'heading' }
  | { type: 'table'; headers: string[]; rows: (string | number)[][]; title?: string }
  | { type: 'image'; data: string; width: number; height: number; caption?: string }
  | { type: 'chart'; elementId: string; caption?: string }
  | { type: 'spacer'; height: number };

export interface PDFTableData {
  title?: string;
  headers: string[];
  rows: (string | number)[][];
  footNote?: string;
  showFooter?: boolean;
}

export interface PDFStatisticalSummary {
  groupName: string;
  metrics: {
    label: string;
    value: string | number;
    unit?: string;
  }[];
}

// ============================================
// PDF GENERATION CLASS
// ============================================

export class ResearchPDFGenerator {
  private doc: any; // jsPDF instance (loaded dynamically)
  private currentPage: number = 1;
  private pageWidth: number;
  private pageHeight: number;
  private marginLeft: number = 25.4; // 1 inch
  private marginRight: number = 25.4;
  private marginTop: number = 25.4;
  private marginBottom: number = 25.4;
  private currentY: number;
  private options: PDFReportOptions;
  private tableOfContents: { title: string; page: number }[] = [];
  private figureNumber: number = 1;
  private tableNumber: number = 1;

  private constructor(doc: any, options: PDFReportOptions) {
    this.options = options;
    this.doc = doc;

    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    this.currentY = this.marginTop;

    // Set default font
    this.doc.setFont('helvetica', 'normal');
  }

  /**
   * Factory method to create ResearchPDFGenerator with dynamic imports
   */
  static async create(options: PDFReportOptions): Promise<ResearchPDFGenerator> {
    const { jsPDF } = await import('jspdf');

    const doc = new jsPDF({
      orientation: options.orientation || 'portrait',
      unit: 'mm',
      format: 'a4',
    });

    return new ResearchPDFGenerator(doc, options);
  }

  /**
   * Add cover page
   */
  addCoverPage(): void {
    const centerX = this.pageWidth / 2;
    const centerY = this.pageHeight / 2;

    // Logo/branding
    this.doc.setFontSize(10);
    this.doc.setTextColor(100, 100, 100);
    this.doc.text('VigIA Research Platform', centerX, 20, { align: 'center' });

    // Title
    this.doc.setFontSize(24);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(10, 38, 71); // #0A2647
    const titleLines = this.doc.splitTextToSize(this.options.title, this.pageWidth - 2 * this.marginLeft);
    this.doc.text(titleLines, centerX, centerY - 40, { align: 'center' });

    // Subtitle
    if (this.options.subtitle) {
      this.doc.setFontSize(16);
      this.doc.setFont('helvetica', 'normal');
      this.doc.setTextColor(50, 50, 50);
      const subtitleLines = this.doc.splitTextToSize(
        this.options.subtitle,
        this.pageWidth - 2 * this.marginLeft
      );
      this.doc.text(subtitleLines, centerX, centerY, { align: 'center' });
    }

    // Author
    this.doc.setFontSize(14);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(80, 80, 80);
    this.doc.text(this.options.author, centerX, centerY + 30, { align: 'center' });

    // Date
    this.doc.setFontSize(12);
    const dateStr = this.options.date.toLocaleDateString(
      this.options.language === 'pt' ? 'pt-BR' : 'en-US',
      {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      }
    );
    this.doc.text(dateStr, centerX, centerY + 45, { align: 'center' });

    // Watermark
    if (this.options.includeWatermark) {
      this.doc.setFontSize(8);
      this.doc.setTextColor(150, 150, 150);
      this.doc.text(
        'Generated by VigIA - Research Data Management System',
        centerX,
        this.pageHeight - 15,
        { align: 'center' }
      );
    }

    this.addNewPage();
  }

  /**
   * Add table of contents
   */
  addTableOfContents(): void {
    this.doc.setFontSize(18);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(10, 38, 71);
    this.doc.text('Table of Contents', this.marginLeft, this.currentY);
    this.currentY += 15;

    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(0, 0, 0);

    this.tableOfContents.forEach((item) => {
      if (this.currentY > this.pageHeight - this.marginBottom) {
        this.addNewPage();
      }

      this.doc.text(item.title, this.marginLeft + 5, this.currentY);
      this.doc.text(
        String(item.page),
        this.pageWidth - this.marginRight - 10,
        this.currentY,
        { align: 'right' }
      );

      // Dotted line
      const dots = '.'.repeat(100);
      this.doc.setTextColor(150, 150, 150);
      this.doc.text(dots, this.marginLeft + 5, this.currentY, {
        maxWidth: this.pageWidth - this.marginLeft - this.marginRight - 20,
      });
      this.doc.setTextColor(0, 0, 0);

      this.currentY += 7;
    });

    this.addNewPage();
  }

  /**
   * Add section heading
   */
  addSectionHeading(title: string, level: 1 | 2 | 3 = 1): void {
    this.tableOfContents.push({ title, page: this.currentPage });

    const fontSizes = { 1: 16, 2: 14, 3: 12 };
    const spacingBefore = { 1: 10, 2: 8, 3: 6 };
    const spacingAfter = { 1: 5, 2: 4, 3: 3 };

    this.currentY += spacingBefore[level];

    if (this.currentY > this.pageHeight - this.marginBottom) {
      this.addNewPage();
    }

    this.doc.setFontSize(fontSizes[level]);
    this.doc.setFont('helvetica', 'bold');
    this.doc.setTextColor(10, 38, 71);
    this.doc.text(title, this.marginLeft, this.currentY);

    this.currentY += spacingAfter[level];

    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(0, 0, 0);
  }

  /**
   * Add paragraph text
   */
  addParagraph(text: string, options: { align?: 'left' | 'justify'; indent?: boolean } = {}): void {
    const { align = 'justify', indent = false } = options;

    const maxWidth = this.pageWidth - this.marginLeft - this.marginRight;
    const startX = this.marginLeft + (indent ? 12.7 : 0); // 0.5 inch indent

    this.doc.setFontSize(12);
    this.doc.setFont('helvetica', 'normal');

    const lines = this.doc.splitTextToSize(text, maxWidth - (indent ? 12.7 : 0));

    lines.forEach((line: string) => {
      if (this.currentY > this.pageHeight - this.marginBottom) {
        this.addNewPage();
      }

      this.doc.text(line, startX, this.currentY, {
        align: align === 'justify' ? 'left' : align,
        maxWidth: maxWidth - (indent ? 12.7 : 0),
      });

      this.currentY += 7;
    });

    this.currentY += 3; // Paragraph spacing
  }

  /**
   * Add APA-style table
   */
  async addTable(data: PDFTableData): Promise<void> {
    // Dynamic import of autoTable
    const autoTable = (await import('jspdf-autotable')).default;

    if (data.title) {
      this.doc.setFontSize(11);
      this.doc.setFont('helvetica', 'italic');
      this.doc.text(`Table ${this.tableNumber}`, this.marginLeft, this.currentY);
      this.currentY += 5;
      this.doc.text(data.title, this.marginLeft, this.currentY);
      this.currentY += 8;
      this.tableNumber++;
    }

    const startY = this.currentY;

    autoTable(this.doc, {
      head: [data.headers],
      body: data.rows as RowInput[],
      startY: startY,
      margin: { left: this.marginLeft, right: this.marginRight },
      styles: {
        font: 'helvetica',
        fontSize: 10,
        cellPadding: 3,
        lineColor: [0, 0, 0],
        lineWidth: 0.1,
      },
      headStyles: {
        fillColor: [255, 255, 255],
        textColor: [0, 0, 0],
        fontStyle: 'bold',
        lineWidth: { top: 0.5, bottom: 0.5, left: 0, right: 0 },
      },
      bodyStyles: {
        fillColor: [255, 255, 255],
        lineWidth: { top: 0, bottom: 0, left: 0, right: 0 },
      },
      footStyles: {
        fillColor: [255, 255, 255],
        lineWidth: { top: 0.5, bottom: 0, left: 0, right: 0 },
      },
      alternateRowStyles: {
        fillColor: [250, 250, 250],
      },
      tableLineWidth: 0.5,
      tableLineColor: [0, 0, 0],
    });

    this.currentY = (this.doc as any).lastAutoTable.finalY + 5;

    if (data.footNote) {
      this.doc.setFontSize(9);
      this.doc.setFont('helvetica', 'italic');
      const noteLines = this.doc.splitTextToSize(
        `Note. ${data.footNote}`,
        this.pageWidth - this.marginLeft - this.marginRight
      );
      noteLines.forEach((line: string) => {
        this.doc.text(line, this.marginLeft, this.currentY);
        this.currentY += 4;
      });
      this.currentY += 3;
    }

    if (data.showFooter) {
      this.doc.setFontSize(9);
      this.doc.setFont('helvetica', 'italic');
      this.doc.text('* p < .05. ** p < .01. *** p < .001.', this.marginLeft, this.currentY);
      this.currentY += 8;
    }
  }

  /**
   * Add statistical summary cards
   */
  addStatisticalSummary(summaries: PDFStatisticalSummary[]): void {
    const cardWidth = (this.pageWidth - this.marginLeft - this.marginRight - 10 * (summaries.length - 1)) / summaries.length;
    const cardHeight = 40;

    summaries.forEach((summary, index) => {
      const x = this.marginLeft + index * (cardWidth + 10);
      const y = this.currentY;

      // Card background
      this.doc.setFillColor(240, 248, 255); // Light blue
      this.doc.rect(x, y, cardWidth, cardHeight, 'F');

      // Card border
      this.doc.setDrawColor(10, 38, 71);
      this.doc.setLineWidth(0.5);
      this.doc.rect(x, y, cardWidth, cardHeight, 'S');

      // Group name
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(10, 38, 71);
      this.doc.text(summary.groupName, x + cardWidth / 2, y + 8, { align: 'center' });

      // Metrics
      let metricY = y + 16;
      this.doc.setFontSize(8);
      this.doc.setFont('helvetica', 'normal');
      this.doc.setTextColor(0, 0, 0);

      summary.metrics.forEach((metric) => {
        const text = `${metric.label}: ${metric.value}${metric.unit ? ' ' + metric.unit : ''}`;
        this.doc.text(text, x + cardWidth / 2, metricY, { align: 'center' });
        metricY += 5;
      });
    });

    this.currentY += cardHeight + 10;
  }

  /**
   * Add image from canvas or buffer
   */
  async addImage(
    imageData: string | Buffer,
    options: {
      width: number;
      height: number;
      caption?: string;
      format?: 'PNG' | 'JPEG';
    }
  ): Promise<void> {
    const { width, height, caption, format = 'PNG' } = options;

    if (this.currentY + height > this.pageHeight - this.marginBottom) {
      this.addNewPage();
    }

    const centerX = (this.pageWidth - width) / 2;

    this.doc.addImage(imageData as any, format, centerX, this.currentY, width, height);
    this.currentY += height + 5;

    if (caption) {
      this.doc.setFontSize(10);
      this.doc.setFont('helvetica', 'italic');
      const captionText = `Figure ${this.figureNumber}. ${caption}`;
      const captionLines = this.doc.splitTextToSize(
        captionText,
        this.pageWidth - this.marginLeft - this.marginRight
      );
      captionLines.forEach((line: string) => {
        this.doc.text(line, this.marginLeft, this.currentY, { align: 'left' });
        this.currentY += 5;
      });
      this.figureNumber++;
      this.currentY += 5;
    }
  }

  /**
   * Capture HTML element as image and add to PDF
   */
  async addChartFromElement(elementId: string, caption?: string): Promise<void> {
    // Dynamic import of html2canvas
    const html2canvas = (await import('html2canvas')).default;

    const element = document.getElementById(elementId);
    if (!element) {
      console.error(`Element with id "${elementId}" not found`);
      return;
    }

    const canvas = await html2canvas(element, {
      scale: 2, // Higher quality
      backgroundColor: '#ffffff',
      logging: false,
    } as any);

    const imgData = canvas.toDataURL('image/png');
    const imgWidth = 160; // Max width in mm
    const imgHeight = (canvas.height * imgWidth) / canvas.width;

    await this.addImage(imgData, {
      width: imgWidth,
      height: imgHeight,
      caption,
      format: 'PNG',
    });
  }

  /**
   * Add spacer
   */
  addSpacer(height: number): void {
    this.currentY += height;
  }

  /**
   * Add page break
   */
  addPageBreak(): void {
    this.addNewPage();
  }

  /**
   * Add new page with header and footer
   */
  private addNewPage(): void {
    this.doc.addPage();
    this.currentPage++;
    this.currentY = this.marginTop;

    this.addHeader();
    this.addFooter();
  }

  /**
   * Add header to current page
   */
  private addHeader(): void {
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(100, 100, 100);

    const headerText = this.options.title.substring(0, 80);
    this.doc.text(headerText, this.marginLeft, 15);

    // Header line
    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.5);
    this.doc.line(this.marginLeft, 18, this.pageWidth - this.marginRight, 18);
  }

  /**
   * Add footer to current page
   */
  private addFooter(): void {
    const footerY = this.pageHeight - 15;

    // Footer line
    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.5);
    this.doc.line(this.marginLeft, footerY - 3, this.pageWidth - this.marginRight, footerY - 3);

    // Page number
    this.doc.setFontSize(10);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(100, 100, 100);
    this.doc.text(`Page ${this.currentPage}`, this.pageWidth / 2, footerY, { align: 'center' });

    // Branding
    if (this.options.includeWatermark) {
      this.doc.setFontSize(8);
      this.doc.setTextColor(150, 150, 150);
      this.doc.text('VigIA', this.pageWidth - this.marginRight, footerY, { align: 'right' });
    }
  }

  /**
   * Generate and download PDF
   */
  save(filename: string): void {
    this.doc.save(filename);
  }

  /**
   * Get PDF as blob
   */
  getBlob(): Blob {
    return this.doc.output('blob');
  }

  /**
   * Get PDF as buffer
   */
  getBuffer(): ArrayBuffer {
    return this.doc.output('arraybuffer');
  }

  /**
   * Get PDF as base64 string
   */
  getBase64(): string {
    return this.doc.output('datauristring');
  }
}

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Capture chart as high-resolution image
 */
export async function captureChartAsImage(
  elementId: string,
  options: { scale?: number; backgroundColor?: string } = {}
): Promise<string> {
  // Dynamic import of html2canvas
  const html2canvas = (await import('html2canvas')).default;

  const { scale = 3, backgroundColor = '#ffffff' } = options;

  const element = document.getElementById(elementId);
  if (!element) {
    throw new Error(`Element with id "${elementId}" not found`);
  }

  const canvas = await html2canvas(element, {
    scale,
    backgroundColor,
    logging: false,
  } as any);

  return canvas.toDataURL('image/png');
}

/**
 * Create quick export PDF (current page only)
 */
export async function quickExportPDF(
  elementId: string,
  filename: string,
  title: string
): Promise<void> {
  const generator = await ResearchPDFGenerator.create({
    title,
    author: 'VigIA User',
    date: new Date(),
    includeTableOfContents: false,
    includeCoverPage: false,
    includeWatermark: true,
    orientation: 'portrait',
    language: 'pt',
  });

  await generator.addChartFromElement(elementId);
  generator.save(filename);
}
